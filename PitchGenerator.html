<!DOCTYPE html>

<html lang="en" xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta charset="utf-8" />
    <title>Grid Generator</title>
    <style>
        body {
            font-family: Segoe UI, Arial, sans-serif;
        }

        form {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
            flex-wrap: wrap;
        }

        label {
            font-size: 14px;
            display: flex;
            gap: 6px;
            align-items: center;
        }

        input[type="text"], input[type="number"] {
            padding: 6px;
        }

        input[type="number"] {
            width: 40px;
        }

        button {
            padding: 6px 10px;
        }

        /* grid container - explicit sizing will be set when generating */
        #grid {
            display: grid;
            gap: 0px;
            margin-top: 12px;
            max-width: 90vw;
            /* prevent scrollbars caused by the grid itself */
            overflow: hidden;
        }

        .square {
            background: #e9eef2;
            border: 1px solid #cfd8de;
            display: flex;
            align-items: center;
            justify-content: center;
            /* cell sizes are set explicitly on the grid */
            width: 100%;
            height: 100%;
            min-width: 0;
            color: #333;
            font-size: 12px;
            user-select: none;
            box-sizing: border-box;
        }

        /* image container palette (static) */
        #image-container {
            display: flex;
            gap: 8px;
            align-items: center;
            margin-bottom: 12px;
        }

            #image-container img {
                position: relative;
                cursor: pointer;
                /* displayed at 5% of original — width set from JS based on naturalWidth */
                height: auto;
                user-select: none;
                -webkit-user-drag: none;
                border: 1px solid transparent;
                transform-origin: center center; /* clones rotate about centre */
            }

                #image-container img:hover {
                    outline: 2px solid rgba(0,0,0,0.08);
                }

        /* clones (created from palette) are absolutely positioned */
        .clone-image {
            position: absolute;
            left: 0;
            top: 0;
            cursor: grab;
            touch-action: none;
            user-select: none;
            -webkit-user-drag: none;
            height: auto;
            z-index: 2000;
            transform-origin: center center; /* rotate around centre */
        }

        /* visual selection style (outline doesn't affect layout) */
        .selected {
            outline: 3px solid #1E90FF;
            outline-offset: 0px;
        }

        /* Trash icon */
        #trash {
            position: fixed;
            right: 18px;
            bottom: 18px;
            width: 64px;
            height: 64px;
            border-radius: 8px;
            background: #fff;
            border: 2px solid #ddd;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            box-shadow: 0 2px 6px rgba(0,0,0,0.12);
            transition: transform 120ms ease, background-color 120ms ease, border-color 120ms ease;
            z-index: 3000;
            user-select: none;
        }

            #trash.over {
                background-color: #ffecec;
                border-color: #f66;
                transform: scale(1.05);
            }
    </style>
</head>
<body>

    <div id="image-container">
        <img class="ontop portal" src="Tiles/portal.png" alt="portal" />
        <img class="ontop chest" src="Tiles/chestb.png" alt="chest" />
        <img class="ontop" src="Tiles/wall-0.png" alt="Wall" />
        <img src="Tiles/corridora-0.jpg" alt="corridor a" />
        <img src="Tiles/tcorridor3rd-0.png" alt="3rd edition T shaped corridor" />
        <img src="Tiles/endzonea-0.jpg" alt="end zone" />
        <img src="Tiles/4x4a.jpg" alt="4 by 4 room" />
        <img src="Tiles/4x8a3rd-0.png" alt="3rd edition 4 by 8 room with chasm" />

    </div>

    <form id="sizeForm" onsubmit="return false;">
        <label for="mapName">
            Map Name
            <input id="mapName" type="text">
        </label>
        <label for="widthInput">
            Width
            <input id="widthInput" type="number" min="1" max="200" value="32" required>
        </label>
        <label for="heightInput">
            Height
            <input id="heightInput" type="number" min="1" max="200" value="18" required>
        </label>
        <button id="generateBtn" type="button">Generate</button>
        <button id="clearBtn" type="button">Clear</button>

        <!-- rotate selected -->
        <button id="rotateSelectedBtn" type="button">Rotate 90°</button>

        <!-- export / import -->
        <button id="downloadBtn" type="button">Save Map</button>
        <button id="chooseFileBtn" type="button">Load Map</button>
        <input id="loadInput" type="file" accept=".json,application/json" style="display:none" />

        <!-- save combined original-scale image -->
        <button id="saveCombinedBtn" type="button">Export Image</button>

    </form>

    <div id="grid" aria-live="polite" role="region" aria-label="Generated grid"></div>

    <div id="trash" title="Drop images here to remove">🗑️</div>

    <script>
        const widthInput = document.getElementById('widthInput');
        const heightInput = document.getElementById('heightInput');
        const mapNameInput = document.getElementById('mapName');
        const grid = document.getElementById('grid');
        const generateBtn = document.getElementById('generateBtn');
        const clearBtn = document.getElementById('clearBtn');
        const downloadBtn = document.getElementById('downloadBtn');
        const chooseFileBtn = document.getElementById('chooseFileBtn');
        const loadInput = document.getElementById('loadInput');
        const trash = document.getElementById('trash');
        const saveCombinedBtn = document.getElementById('saveCombinedBtn');
        const rotateSelectedBtn = document.getElementById('rotateSelectedBtn');

        // store last-generated grid dimensions so snapping can use them
        let gridCols = 0;
        let gridRows = 0;
        // store last calculated cell size used to draw grid (displayed pixels)
        let currentCellSize = 0;

        // mapping of imageId -> { col, row, src, origW, origH, ontop, classList } after last snap
        const imageGridRefs = {};

        // internal set of clones so we can manage them
        const clones = new Set();

        // currently selected clone element
        let selectedClone = null;

        // scale for display (5% of original)
        const DISPLAY_SCALE = 0.10;

        // z-index counters: normal and ontop
        let nextZ = 2000;
        let nextOntopZ = 100000;

        // ---------------- initialize palette scaling ----------------
        function scalePaletteImages() {
            const paletteImages = Array.from(document.querySelectorAll('#image-container img'));
            paletteImages.forEach(img => {
                // When naturalWidth available, set displayed width to DISPLAY_SCALE of original.
                if (img.complete && img.naturalWidth) {
                    const w = Math.max(1, Math.round(img.naturalWidth * DISPLAY_SCALE));
                    img.style.width = w + 'px';
                    img.dataset.origWidth = String(img.naturalWidth);
                    img.dataset.origHeight = String(img.naturalHeight || Math.round(img.naturalWidth * (img.naturalHeight / img.naturalWidth || 1)));
                } else {
                    // attach load handler
                    img.addEventListener('load', () => {
                        const w = Math.max(1, Math.round(img.naturalWidth * DISPLAY_SCALE));
                        img.style.width = w + 'px';
                        img.dataset.origWidth = String(img.naturalWidth);
                        img.dataset.origHeight = String(img.naturalHeight || Math.round(img.naturalWidth * (img.naturalHeight / img.naturalWidth || 1)));
                    }, { once: true });
                }
            });
        }

        // call initially
        scalePaletteImages();

        // ---------------- selection helpers ----------------
        function selectClone(img) {
            if (!img) return;
            if (selectedClone && selectedClone !== img) {
                deselectClone(selectedClone);
            }
            selectedClone = img;
            img.classList.add('selected');
        }

        function deselectClone(img) {
            if (!img) return;
            img.classList.remove('selected');
            if (selectedClone === img) selectedClone = null;
        }

        function toggleSelect(img) {
            if (!img) return;
            if (selectedClone === img) {
                deselectClone(img);
            } else {
                selectClone(img);
            }
        }

        // ---------------- grid logic ----------------
        function createGrid(cols, rows) {
            grid.innerHTML = '';
            gridCols = cols;
            gridRows = rows;
            if (cols < 1 || rows < 1) return;

            const gridRect = grid.getBoundingClientRect();
            const gridLeft = (gridRect.left || grid.offsetLeft || 20);
            const gridTop = (gridRect.top || grid.offsetTop || (document.querySelector('form').getBoundingClientRect().bottom + 12));

            const margin = 12;
            const availableWidth = Math.max(0, window.innerWidth - gridLeft - margin);
            const availableHeight = Math.max(0, window.innerHeight - gridTop - margin);

            const desiredCellSize = 20;
            const maxCellByWidth = Math.floor(availableWidth / cols) || 0;
            const maxCellByHeight = Math.floor(availableHeight / rows) || 0;
            let cellSize = Math.min(desiredCellSize, maxCellByWidth, maxCellByHeight);
            if (cellSize < 1) cellSize = 1;

            currentCellSize = cellSize;

            grid.style.gridTemplateColumns = `repeat(${cols}, ${cellSize}px)`;
            grid.style.gridAutoRows = `${cellSize}px`;
            grid.style.width = `${cols * cellSize}px`;
            grid.style.height = `${rows * cellSize}px`;

            for (let r = 0; r < rows; r++) {
                for (let c = 0; c < cols; c++) {
                    const cell = document.createElement('div');
                    cell.className = 'square';
                    grid.appendChild(cell);
                }
            }
        }

        generateBtn.addEventListener('click', () => {
            const cols = parseInt(widthInput.value, 10);
            const rows = parseInt(heightInput.value, 10);
            if (!Number.isInteger(cols) || !Number.isInteger(rows) || cols < 1 || rows < 1) {
                alert('Please enter positive integers for width and height.');
                return;
            }
            createGrid(cols, rows);
        });

        // Confirm clear before proceeding
        clearBtn.addEventListener('click', () => {
            const ok = confirm('Clear the grid and remove all placed images? This cannot be undone.');
            if (!ok) return;

            grid.innerHTML = '';
            gridCols = 0;
            gridRows = 0;
            grid.style.width = '';
            grid.style.height = '';
            currentCellSize = 0;

            // remove all clones from DOM and clear refs
            clones.forEach(c => {
                if (c && c.parentNode) c.parentNode.removeChild(c);
            });
            clones.clear();

            Object.keys(imageGridRefs).forEach(k => delete imageGridRefs[k]);
            // remove dataset attributes from any remaining images (palette)
            document.querySelectorAll('#image-container img').forEach(img => {
                delete img.dataset.gridCol;
                delete img.dataset.gridRow;
            });

            // clear selection
            selectedClone = null;
        });

        // utility: clamp a position so element stays inside viewport
        function clampPosition(left, top, elem) {
            const w = elem.offsetWidth;
            const h = elem.offsetHeight;
            const maxLeft = Math.max(0, window.innerWidth - w);
            const maxTop = Math.max(0, window.innerHeight - h);
            return {
                left: Math.min(Math.max(0, left), maxLeft),
                top: Math.min(Math.max(0, top), maxTop)
            };
        }

        // expose a helper to read the recorded grid references (returns shallow copy)
        window.getImageGridRefs = () => ({ ...imageGridRefs });

        // ---------------- clone creation & dragging ----------------

        // helper to compute a snap position from (col,row) -> {left, top}
        function snapPositionFor(col, row) {
            if (!gridCols || !gridRows || !currentCellSize) return null;
            const gridRect = grid.getBoundingClientRect();
            const cellWidth = currentCellSize;
            const cellHeight = currentCellSize;
            return {
                left: gridRect.left + col * cellWidth,
                top: gridRect.top + row * cellHeight,
                cellWidth,
                cellHeight,
                gridRect
            };
        }

        // New helper: snap the top-left corner of `img` to nearest grid intersection
        function snapTopLeftToGrid(img) {
            if (!gridCols || !gridRows || !currentCellSize) return;
            const gridRect = grid.getBoundingClientRect();
            const cellW = currentCellSize;
            const cellH = currentCellSize;

            // Try to read explicit style.left/top (px). If not present, fallback to bounding rect.
            let left = parseFloat(img.style.left);
            let top = parseFloat(img.style.top);

            if (!Number.isFinite(left) || !Number.isFinite(top)) {
                const rect = img.getBoundingClientRect();
                left = rect.left;
                top = rect.top;
            }

            // Convert to coordinates relative to grid
            const relX = left - gridRect.left;
            const relY = top - gridRect.top;

            let col = Math.round(relX / cellW);
            let row = Math.round(relY / cellH);

            // Clamp into valid intersection range [0..cols]
            col = Math.min(Math.max(0, col), gridCols);
            row = Math.min(Math.max(0, row), gridRows);

            const snapLeft = gridRect.left + col * cellW;
            const snapTop = gridRect.top + row * cellH;

            const clamped = clampPosition(snapLeft, snapTop, img);
            img.style.left = clamped.left + 'px';
            img.style.top = clamped.top + 'px';

            // update dataset and recorded refs
            const origW = Number(img.dataset.origWidth || img.naturalWidth || img.width || 0);
            const origH = Number(img.dataset.origHeight || img.naturalHeight || img.height || 0);
            const ontopFlag = img.classList.contains('ontop');
            const classes = Array.from(img.classList);
            img.dataset.gridCol = String(col);
            img.dataset.gridRow = String(row);
            img.dataset.origWidth = String(origW);
            img.dataset.origHeight = String(origH);
            // keep src but do not force-saving rotation into exported JSON (export step strips rot)
            imageGridRefs[img.id] = { col, row, src: img.src, origW, origH, ontop: ontopFlag, classList: classes };
        }

        // helper to update displayed width from dataset.origWidth (used by clones after swaps)
        function updateDisplayedSizeFor(img) {
            let oW = Number(img.dataset.origWidth);
            if (!oW && img.naturalWidth) oW = img.naturalWidth;
            oW = oW || 20;
            const dispW = Math.max(1, Math.round(oW * DISPLAY_SCALE));
            img.style.width = dispW + 'px';
        }

        // helper: test that an image URL loads successfully
        function testImageExists(url, timeout = 7000) {
            return new Promise((resolve) => {
                if (!url) { resolve(false); return; }
                const tester = new Image();
                let done = false;
                const onSuccess = () => { if (done) return; done = true; cleanup(); resolve(true); };
                const onFail = () => { if (done) return; done = true; cleanup(); resolve(false); };
                const cleanup = () => {
                    tester.onload = tester.onerror = null;
                    if (timer) clearTimeout(timer);
                };
                tester.onload = onSuccess;
                tester.onerror = onFail;
                tester.crossOrigin = 'anonymous';
                tester.src = url;
                const timer = setTimeout(() => {
                    if (done) return;
                    done = true;
                    cleanup();
                    resolve(false);
                }, timeout);
            });
        }

        // sanitize a user-provided map name for use in filenames
        function safeFileName(name) {
            if (!name) return '';
            let s = String(name).trim();
            if (!s) return '';
            // remove characters commonly invalid in filenames, convert spaces to hyphens
            s = s.replace(/[:\/\\?%*|"<>]/g, '');
            s = s.replace(/\s+/g, '-');
            // allow only safe characters
            s = s.replace(/[^A-Za-z0-9\-_\.]/g, '');
            // trim
            s = s.substring(0, 120);
            return s || '';
        }

        // ---------------- palette click -> create clone ----------------
        (function wirePalette() {
            const paletteImages = Array.from(document.querySelectorAll('#image-container img'));
            paletteImages.forEach((img) => {
                // ensure orig sizes set for palette
                if (img.complete && img.naturalWidth) {
                    img.dataset.origWidth = String(img.naturalWidth);
                    img.dataset.origHeight = String(img.naturalHeight || 0);
                    // apply displayed width (in case loaded after earlier)
                    img.style.width = Math.max(1, Math.round(img.naturalWidth * DISPLAY_SCALE)) + 'px';
                } else {
                    img.addEventListener('load', () => {
                        img.dataset.origWidth = String(img.naturalWidth);
                        img.dataset.origHeight = String(img.naturalHeight || 0);
                        img.style.width = Math.max(1, Math.round(img.naturalWidth * DISPLAY_SCALE)) + 'px';
                    }, { once: true });
                }

                img.addEventListener('click', (ev) => {
                    // create clone of clicked palette item; pass orig sizes and ontop flag and classes
                    const origW = Number(img.dataset.origWidth || img.naturalWidth || 0);
                    const origH = Number(img.dataset.origHeight || img.naturalHeight || 0);
                    const isOntop = img.classList.contains('ontop');
                    createCloneFromPalette(img.src, origW, origH, 0, null, isOntop, img.classList);
                });
            });
        })();

        // helper: replace or insert rotation number in filename portion of a src
        function replaceRotationInSrc(src, rot) {
            // preserve query/hash suffix
            const qIndex = src.indexOf('?');
            const hIndex = src.indexOf('#');
            let suffixIndex = src.length;
            if (qIndex !== -1) suffixIndex = Math.min(suffixIndex, qIndex);
            if (hIndex !== -1) suffixIndex = Math.min(suffixIndex, hIndex);
            const base = src.substring(0, suffixIndex);
            const suffix = src.substring(suffixIndex);

            // find filename portion
            const lastSlash = base.lastIndexOf('/');
            const filename = base.substring(lastSlash + 1);
            const dir = base.substring(0, lastSlash + 1);

            const dot = filename.lastIndexOf('.');
            if (dot === -1) {
                // no extension — just append -rot
                return dir + filename + '-' + String(rot) + suffix;
            }
            const name = filename.substring(0, dot);
            const ext = filename.substring(dot);

            const dash = name.lastIndexOf('-');
            if (dash !== -1) {
                const afterDash = name.substring(dash + 1);
                if (/^\d+$/.test(afterDash)) {
                    // replace existing numeric token
                    const newName = name.substring(0, dash + 1) + String(rot);
                    return dir + newName + ext + suffix;
                }
            }

            // no numeric suffix to replace — insert -rot
            return dir + name + '-' + String(rot) + ext + suffix;
        }

        // helper: parse rotation degrees from src filename (last numeric token after '-' before extension)
        function rotationFromSrc(src) {
            if (!src) return 0;
            // ignore query/hash
            const qIndex = src.indexOf('?');
            const hIndex = src.indexOf('#');
            let end = src.length;
            if (qIndex !== -1) end = Math.min(end, qIndex);
            if (hIndex !== -1) end = Math.min(end, hIndex);
            const base = src.substring(0, end);
            const lastSlash = base.lastIndexOf('/');
            const filename = base.substring(lastSlash + 1);
            const dot = filename.lastIndexOf('.');
            const name = dot === -1 ? filename : filename.substring(0, dot);
            const dash = name.lastIndexOf('-');
            if (dash === -1) return 0;
            const token = name.substring(dash + 1);
            if (/^\d+$/.test(token)) {
                const n = parseInt(token, 10) % 360;
                return Number.isFinite(n) ? n : 0;
            }
            return 0;
        }

        // create a clone image from a palette image, preserve ontop flag, snap it to grid top-left (0,0) if grid exists
        function createCloneFromPalette(src, origW, origH, rot = 0, id = null, isOntop = false, classList = null) {
            const uid = id || `clone-${Date.now()}-${Math.random().toString(36).slice(2, 7)}`;
            const img = document.createElement('img');
            img.src = src;
            img.id = uid;
            img.className = 'clone-image';
            if (classList && classList.length > 0) {
                // apply classes from provided classList (preserve anything useful like 'portal','chest','ontop', etc.)
                Array.from(classList).forEach(cls => {
                    if (cls !== 'clone-image') img.classList.add(cls);
                });
            }
            img.draggable = false;
            // Rotation is encoded in src filename — do not set CSS rotate or store rotation in dataset.
            img.style.transformOrigin = 'center center';

            // set z-index according to ontop flag so ontop clones always above others
            if (isOntop || img.classList.contains('ontop')) {
                img.style.zIndex = String(nextOntopZ++);
            } else {
                img.style.zIndex = String(nextZ++);
            }

            document.body.appendChild(img);
            clones.add(img);

            // store original size on dataset (if known)
            if (origW && origH) {
                img.dataset.origWidth = String(origW);
                img.dataset.origHeight = String(origH);
            } else {
                // if not provided, wait for load to populate
                img.addEventListener('load', () => {
                    img.dataset.origWidth = String(img.naturalWidth || img.width || 1);
                    img.dataset.origHeight = String(img.naturalHeight || img.height || 1);
                }, { once: true });
            }

            // displayed size: use helper which reads dataset.origWidth
            img.addEventListener('load', () => updateDisplayedSizeFor(img), { once: true });
            // also call immediately in case already loaded / dataset set
            updateDisplayedSizeFor(img);

            // default position: grid top-left intersection (0,0) if grid exists, otherwise near top-left
            if (gridCols > 0 && gridRows > 0 && currentCellSize > 0) {
                const snap = snapPositionFor(0, 0);
                if (snap) {
                    const clamped = clampPosition(snap.left, snap.top, img);
                    img.style.left = clamped.left + 'px';
                    img.style.top = clamped.top + 'px';
                    // record ref (orig sizes might be filled later)
                    img.dataset.gridCol = '0';
                    img.dataset.gridRow = '0';
                    const classes = Array.from(img.classList);
                    // keep src recorded; rot is intentionally not required in saved JSON (export strips it)
                    imageGridRefs[img.id] = { col: 0, row: 0, src: img.src, origW: Number(img.dataset.origWidth || 0), origH: Number(img.dataset.origHeight || 0), ontop: isOntop || img.classList.contains('ontop'), classList: classes };
                }
            } else {
                // place near top-left if no grid
                img.style.left = '20px';
                img.style.top = '20px';
            }

            // newly created clones should be selected
            selectClone(img);

            enableDraggingOn(img);
            return img;
        }

        // enable dragging & snapping & trash-drop for a clone image
        function enableDraggingOn(img) {
            let dragging = false;
            let moved = false;
            let startX = 0, startY = 0;
            let origLeft = 0, origTop = 0;
            let overTrash = false;
            let pointerId = null;
            const MOVE_THRESHOLD = 4; // px to distinguish click vs drag

            function checkOverTrash(imgRect) {
                const tRect = trash.getBoundingClientRect();
                return !(imgRect.right < tRect.left || imgRect.left > tRect.right || imgRect.bottom < tRect.top || imgRect.top > tRect.bottom);
            }

            img.addEventListener('pointerdown', (ev) => {
                // prevent default to avoid native drag and clicks interfering
                ev.preventDefault();

                // bring to front respecting ontop
                if (img.classList.contains('ontop')) {
                    img.style.zIndex = String(nextOntopZ++);
                } else {
                    img.style.zIndex = String(nextZ++);
                }

                pointerId = ev.pointerId;
                img.setPointerCapture(pointerId);
                dragging = true;
                moved = false;
                img.style.cursor = 'grabbing';
                startX = ev.clientX;
                startY = ev.clientY;
                const rect = img.getBoundingClientRect();
                origLeft = rect.left;
                origTop = rect.top;

                function onMove(moveEv) {
                    if (!dragging || moveEv.pointerId !== pointerId) return;
                    moveEv.preventDefault();
                    const dx = moveEv.clientX - startX;
                    const dy = moveEv.clientY - startY;
                    if (!moved && Math.hypot(dx, dy) > MOVE_THRESHOLD) moved = true;
                    const newLeft = origLeft + dx;
                    const newTop = origTop + dy;
                    const pos = clampPosition(newLeft, newTop, img);
                    img.style.left = pos.left + 'px';
                    img.style.top = pos.top + 'px';

                    // indicate trash hover
                    const imgRect = img.getBoundingClientRect();
                    const currentlyOver = checkOverTrash(imgRect);
                    if (currentlyOver !== overTrash) {
                        overTrash = currentlyOver;
                        if (overTrash) trash.classList.add('over'); else trash.classList.remove('over');
                    }
                }

                function onUp(upEv) {
                    if (upEv.pointerId !== pointerId) return;
                    upEv.preventDefault();
                    dragging = false;
                    img.style.cursor = 'grab';
                    try { img.releasePointerCapture(pointerId); } catch (e) { /* ignore */ }

                    document.removeEventListener('pointermove', onMove);
                    document.removeEventListener('pointerup', onUp);

                    // if this interaction was a click (no move) toggle selection
                    if (!moved) {
                        // clicking a selected img should deselect it; a new click selects it otherwise.
                        toggleSelect(img);
                        return;
                    }

                    // if dropped on trash -> remove
                    const imgRect = img.getBoundingClientRect();
                    const isOver = checkOverTrash(imgRect);
                    trash.classList.remove('over');
                    if (isOver) {
                        // remove element and clean refs
                        if (selectedClone === img) selectedClone = null;
                        if (img.parentNode) img.parentNode.removeChild(img);
                        clones.delete(img);
                        delete imageGridRefs[img.id];
                        return;
                    }

                    // Otherwise snap top-left to nearest grid intersection (top-left of image)
                    if (gridCols > 0 && gridRows > 0 && grid.children.length > 0) {
                        snapTopLeftToGrid(img);
                        // ensure clone is selected after dragging
                        selectClone(img);
                    } else {
                        // if no grid, remove refs
                        delete img.dataset.gridCol;
                        delete img.dataset.gridRow;
                        delete imageGridRefs[img.id];

                        // ensure clone is selected after dragging even when no grid
                        selectClone(img);
                    }
                }

                document.addEventListener('pointermove', onMove);
                document.addEventListener('pointerup', onUp);
            }, { passive: false });
        }

        // rotate selected button — use rotation encoded in src filename instead of dataset
        rotateSelectedBtn.addEventListener('click', async () => {
            if (!selectedClone) {
                alert('No image selected.');
                return;
            }
            const img = selectedClone;

            // read current rotation from src, increment by 90, write back into src if the rotated resource exists
            const current = rotationFromSrc(img.src) || 0;
            const newRot = (current + 90) % 360;
            const newSrc = replaceRotationInSrc(img.src || '', newRot);

            // Test resource exists before switching
            const exists = await testImageExists(newSrc);
            if (!exists) {
                //alert('Cannot rotate: rotated image resource not found:\n' + newSrc);
                return;
            }

            try {
                if (newSrc !== img.src) {
                    img.src = newSrc;
                }
            } catch (e) {
                console.warn('Failed to update image src for rotation', e);
                alert('Failed to update image source for rotation.');
                return;
            }

            // Clear any CSS transform as rotation is represented by filename now
            img.style.transform = '';

            // Swap original width/height so rotated image has dimensions swapped.
            const prevOrigW = Number(img.dataset.origWidth || img.naturalWidth || img.width || 0);
            const prevOrigH = Number(img.dataset.origHeight || img.naturalHeight || img.height || 0);
            img.dataset.origWidth = String(prevOrigH);
            img.dataset.origHeight = String(prevOrigW);

            // update displayed size to reflect swapped orientation
            updateDisplayedSizeFor(img);

            // update recorded ref if present (include classList and updated src and swapped orig sizes)
            if (imageGridRefs[img.id]) {
                const classes = Array.from(img.classList);
                imageGridRefs[img.id].classList = classes;
                imageGridRefs[img.id].src = img.src;
                imageGridRefs[img.id].origW = Number(img.dataset.origWidth || 0);
                imageGridRefs[img.id].origH = Number(img.dataset.origHeight || 0);
            } else {
                imageGridRefs[img.id] = {
                    col: Number(img.dataset.gridCol || 0),
                    row: Number(img.dataset.gridRow || 0),
                    src: img.src,
                    origW: Number(img.dataset.origWidth || 0),
                    origH: Number(img.dataset.origHeight || 0),
                    ontop: img.classList.contains('ontop'),
                    classList: Array.from(img.classList)
                };
            }

            // after rotation, snap the top-left corner of the cloned img to the nearest grid intersection
            if (gridCols > 0 && gridRows > 0 && grid.children.length > 0) {
                requestAnimationFrame(() => {
                    snapTopLeftToGrid(img);
                });
            }
        });

        // ---------------- keyboard: move selected by one grid cell on arrow keys ----------------
        window.addEventListener('keydown', (ev) => {
            // only act for arrow keys
            const moves = {
                'ArrowLeft': [-1, 0],
                'ArrowRight': [1, 0],
                'ArrowUp': [0, -1],
                'ArrowDown': [0, 1]
            };
            if (!moves.hasOwnProperty(ev.key)) return;

            // don't interfere when user is typing in an input/textarea/contenteditable
            const active = document.activeElement;
            if (active && (active.tagName === 'INPUT' || active.tagName === 'TEXTAREA' || active.isContentEditable)) return;

            if (!selectedClone) return;
            // require a grid to snap positions
            if (!gridCols || !gridRows || !currentCellSize) return;

            ev.preventDefault();

            const [dx, dy] = moves[ev.key];

            // resolve current col/row for selected clone
            let col = Number(selectedClone.dataset.gridCol);
            let row = Number(selectedClone.dataset.gridRow);

            if (!Number.isFinite(col) || !Number.isFinite(row)) {
                const ref = imageGridRefs[selectedClone.id];
                if (ref && Number.isFinite(ref.col) && Number.isFinite(ref.row)) {
                    col = ref.col;
                    row = ref.row;
                } else {
                    // fallback: snap to nearest grid if possible
                    const rect = selectedClone.getBoundingClientRect();
                    const gridRect = grid.getBoundingClientRect();
                    col = Math.round((rect.left - gridRect.left) / currentCellSize);
                    row = Math.round((rect.top - gridRect.top) / currentCellSize);
                }
            }

            let newCol = Math.min(Math.max(0, col + dx), gridCols);
            let newRow = Math.min(Math.max(0, row + dy), gridRows);

            // if nothing changes, bail out
            if (newCol === col && newRow === row) return;

            const snap = snapPositionFor(newCol, newRow);
            if (!snap) return;

            const clamped = clampPosition(snap.left, snap.top, selectedClone);
            selectedClone.style.left = clamped.left + 'px';
            selectedClone.style.top = clamped.top + 'px';
            selectedClone.dataset.gridCol = String(newCol);
            selectedClone.dataset.gridRow = String(newRow);

            // update recorded refs
            if (!imageGridRefs[selectedClone.id]) {
                imageGridRefs[selectedClone.id] = {
                    col: newCol,
                    row: newRow,
                    src: selectedClone.src,
                    origW: Number(selectedClone.dataset.origWidth || 0),
                    origH: Number(selectedClone.dataset.origHeight || 0),
                    ontop: selectedClone.classList.contains('ontop'),
                    classList: Array.from(selectedClone.classList)
                };
            } else {
                imageGridRefs[selectedClone.id].col = newCol;
                imageGridRefs[selectedClone.id].row = newRow;
                imageGridRefs[selectedClone.id].classList = Array.from(selectedClone.classList);
            }

            try {
                selectedClone.dispatchEvent(new CustomEvent('snappedToGrid', {
                    detail: { id: selectedClone.id, col: newCol, row: newRow },
                    bubbles: true,
                }));
            } catch (e) { /* ignore */ }
        });

        // ---------------- Export / Import JSON of image grid refs ----------------
        downloadBtn.addEventListener('click', () => {
            // Build an export refs object that excludes any rotation data.
            const refsForExport = {};
            Object.keys(imageGridRefs).forEach(k => {
                const r = imageGridRefs[k];
                // copy and explicitly omit 'rot' if present
                const copy = {
                    col: r.col,
                    row: r.row,
                    src: r.src,
                    origW: r.origW,
                    origH: r.origH,
                    ontop: r.ontop,
                    classList: r.classList
                };
                refsForExport[k] = copy;
            });

            const payload = {
                cols: gridCols,
                rows: gridRows,
                refs: refsForExport
            };

            if ((!payload.cols || !payload.rows) && Object.keys(payload.refs).length === 0) {
                alert('No grid or image references to download.');
                return;
            }

            const json = JSON.stringify(payload, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');

            const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
            const mapSafe = safeFileName(mapNameInput && mapNameInput.value ? mapNameInput.value : '');
            if (mapSafe) {
                a.download = `${mapSafe}-${timestamp}.json`;
            } else {
                a.download = `image-grid-refs-${timestamp}.json`;
            }

            a.href = url;
            document.body.appendChild(a);
            a.click();
            setTimeout(() => {
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
            }, 100);
        });

        chooseFileBtn.addEventListener('click', () => loadInput.click());

        loadInput.addEventListener('change', (ev) => {
            const file = ev.target.files && ev.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = () => {
                try {
                    const data = JSON.parse(String(reader.result));
                    if (!data || typeof data !== 'object') throw new Error('Invalid JSON');

                    // If file contains grid dimensions, recreate grid so snaps / positions match file
                    if (Number.isInteger(data.cols) && Number.isInteger(data.rows) && data.cols > 0 && data.rows > 0) {
                        createGrid(data.cols, data.rows);
                    } else if (!gridCols || !gridRows) {
                        alert('Loaded file does not contain grid size and there is no active grid. Generate a grid first or use a file that includes grid size.');
                        loadInput.value = '';
                        return;
                    }

                    const refs = data.refs || {};
                    const gridRect = grid.getBoundingClientRect();
                    const cellWidth = currentCellSize || (gridRect.width / gridCols);
                    const cellHeight = currentCellSize || (gridRect.height / gridRows);

                    Object.keys(refs).forEach(id => {
                        const ref = refs[id];
                        if (!ref || typeof ref.col !== 'number' || typeof ref.row !== 'number') return;

                        let img = document.getElementById(id);
                        // if image doesn't exist in DOM but we have src, recreate clone with provided orig size.
                        // Do NOT load or apply rotation from the JSON (rotation is encoded in filename/src).
                        if (!img && ref.src) {
                            img = createCloneFromPalette(ref.src, ref.origW, ref.origH, 0, id, !!ref.ontop, ref.classList || null);
                        }

                        if (!img) {
                            console.warn(`Image with id "${id}" not found in DOM and no src provided, skipping.`);
                            return;
                        }

                        // clamp indices
                        const col = Math.min(Math.max(0, Math.round(ref.col)), gridCols);
                        const row = Math.min(Math.max(0, Math.round(ref.row)), gridRows);

                        const snapLeft = gridRect.left + col * cellWidth;
                        const snapTop = gridRect.top + row * cellHeight;
                        const clamped = clampPosition(snapLeft, snapTop, img);
                        img.style.left = clamped.left + 'px';
                        img.style.top = clamped.top + 'px';

                        // record refs on element and global map (do not apply ref.rot)
                        img.dataset.gridCol = String(col);
                        img.dataset.gridRow = String(row);
                        img.dataset.origWidth = String(ref.origW || img.dataset.origWidth || img.naturalWidth || 0);
                        img.dataset.origHeight = String(ref.origH || img.dataset.origHeight || img.naturalHeight || 0);
                        // intentionally do not set dataset.rot or style.transform from file
                        const ontopFlag = !!ref.ontop || img.classList.contains('ontop');
                        if (ontopFlag) img.classList.add('ontop'); else img.classList.remove('ontop');

                        // ensure classList is applied and recorded
                        if (Array.isArray(ref.classList)) {
                            // apply any classes from ref that aren't already on the element
                            ref.classList.forEach(cls => {
                                if (!img.classList.contains(cls)) img.classList.add(cls);
                            });
                        }
                        const classes = Array.from(img.classList);
                        // store refs but do not include rot from file
                        imageGridRefs[img.id] = { col, row, src: img.src, origW: Number(img.dataset.origWidth || 0), origH: Number(img.dataset.origHeight || 0), ontop: ontopFlag, classList: classes };

                        try {
                            img.dispatchEvent(new CustomEvent('snappedToGrid', {
                                detail: { id: img.id, col, row },
                                bubbles: true,
                            }));
                        } catch (e) { /* ignore */ }
                    });

                    alert('Loaded image grid references.');
                } catch (err) {
                    console.error(err);
                    alert('Failed to load JSON file: ' + (err && err.message ? err.message : 'unknown error'));
                } finally {
                    loadInput.value = '';
                }
            };
            reader.onerror = () => {
                alert('Failed to read file.');
                loadInput.value = '';
            };
            reader.readAsText(file);
        });

        // ---------------- Save combined original-scale image ----------------
        // We'll add PNG tEXt chunk containing metadata JSON under keyword "mapJSON".
        // Helpers below insert tEXt chunk(s) before IEND and compute CRC.
        function crc32Buf(buf) {
            // buf: Uint8Array
            const table = crc32Buf.table || (crc32Buf.table = (function () {
                const t = new Uint32Array(256);
                for (let i = 0; i < 256; i++) {
                    let c = i;
                    for (let k = 0; k < 8; k++) {
                        if (c & 1) c = 0xedb88320 ^ (c >>> 1);
                        else c = c >>> 1;
                    }
                    t[i] = c >>> 0;
                }
                return t;
            })());
            let crc = 0xffffffff;
            for (let i = 0; i < buf.length; i++) {
                crc = (crc >>> 8) ^ table[(crc ^ buf[i]) & 0xff];
            }
            return (crc ^ 0xffffffff) >>> 0;
        }

        function uint32ToBytesBE(n) {
            return new Uint8Array([
                (n >>> 24) & 0xff,
                (n >>> 16) & 0xff,
                (n >>> 8) & 0xff,
                n & 0xff
            ]);
        }

        async function addPngTextChunk(blob, keyword, text) {
            const ab = await blob.arrayBuffer();
            const src = new Uint8Array(ab);
            // PNG signature 8 bytes
            const sig = src.subarray(0, 8);
            // parse chunks to find start of IEND
            let offset = 8;
            let iendOffset = -1;
            while (offset + 8 <= src.length) {
                const length = (src[offset] << 24) | (src[offset + 1] << 16) | (src[offset + 2] << 8) | src[offset + 3];
                const type = String.fromCharCode(src[offset + 4], src[offset + 5], src[offset + 6], src[offset + 7]);
                if (type === 'IEND') { iendOffset = offset; break; }
                offset += 8 + length + 4; // length + type + data + crc
            }
            if (iendOffset < 0) {
                // cannot find IEND - return original
                return blob;
            }

            // create tEXt chunk: data = keyword + 0x00 + text (Latin1). We'll encode as UTF-8 in iTXt would be better,
            // but tEXt is acceptable. Use keyword 'mapJSON' and value JSON.
            const encoder = new TextEncoder();
            const keywordBytes = encoder.encode(keyword); // keywords should be ASCII; ok
            const textBytes = encoder.encode(text);
            const data = new Uint8Array(keywordBytes.length + 1 + textBytes.length);
            data.set(keywordBytes, 0);
            data[keywordBytes.length] = 0;
            data.set(textBytes, keywordBytes.length + 1);

            const typeBytes = new Uint8Array([0x74, 0x45, 0x58, 0x74]); // 'tEXt'
            const lengthBytes = uint32ToBytesBE(data.length);
            // compute crc over type + data
            const crcInput = new Uint8Array(typeBytes.length + data.length);
            crcInput.set(typeBytes, 0);
            crcInput.set(data, typeBytes.length);
            const crc = crc32Buf(crcInput);
            const crcBytes = uint32ToBytesBE(crc);

            // assemble new chunk bytes
            const chunk = new Uint8Array(4 + 4 + data.length + 4);
            chunk.set(lengthBytes, 0);
            chunk.set(typeBytes, 4);
            chunk.set(data, 8);
            chunk.set(crcBytes, 8 + data.length);

            // build new PNG: src[0..iendOffset-1] + chunk + src[iendOffset .. end]
            const before = src.subarray(0, iendOffset);
            const after = src.subarray(iendOffset);
            const out = new Uint8Array(before.length + chunk.length + after.length);
            out.set(before, 0);
            out.set(chunk, before.length);
            out.set(after, before.length + chunk.length);

            return new Blob([out], { type: 'image/png' });
        }

        // helper to build metadata object for mapName, portals and chests
        // now accepts originalCellSize (pixels in the combined/original coordinate space) so we can record offsets
        function buildMetadata(originalCellSize) {
            const mapName = (mapNameInput && mapNameInput.value) ? String(mapNameInput.value) : '';
            const gather = (cls) => {
                const arr = [];
                document.querySelectorAll(`.clone-image.${cls}`).forEach(el => {
                    // prefer recorded refs
                    const ref = imageGridRefs[el.id];
                    let col = null, row = null;
                    if (ref && typeof ref.col === 'number' && typeof ref.row === 'number') {
                        col = ref.col;
                        row = ref.row;
                    } else {
                        const c = parseInt(el.dataset.gridCol, 10);
                        const r = parseInt(el.dataset.gridRow, 10);
                        if (!Number.isNaN(c)) col = c;
                        if (!Number.isNaN(r)) row = r;
                    }
                    if (col === null || row === null) {
                        // skip items that don't have grid refs
                        return;
                    }
                    // compute pixel offsets inside combined/original-scale image if originalCellSize provided
                    let offsetX = undefined, offsetY = undefined;
                    if (typeof originalCellSize === 'number' && Number.isFinite(originalCellSize)) {
                        offsetX = Math.round(col * originalCellSize);
                        offsetY = Math.round(row * originalCellSize);
                    }
                    const item = { col, row };
                    if (offsetX !== undefined && offsetY !== undefined) {
                        item.offsetX = offsetX;
                        item.offsetY = offsetY;
                    }
                    arr.push(item);
                });
                return arr;
            };

            return {
                mapName,
                width: widthInput ? parseInt(widthInput.value, 10) : 0,
                height: heightInput ? parseInt(heightInput.value, 10) : 0,
                portals: gather('portal'),
                chests: gather('chest')
            };
        }

        saveCombinedBtn.addEventListener('click', async () => {
            if (!gridCols || !gridRows || !currentCellSize) {
                alert('Generate a grid first.');
                return;
            }
            // Collect refs that have positions
            const refs = Object.entries(imageGridRefs).map(([id, r]) => ({ id, ...r }));
            if (refs.length === 0) {
                alert('No placed images to combine.');
                return;
            }

            // compute original per-cell size assuming displayed cell = currentCellSize = originalCellSize * DISPLAY_SCALE
            // so originalCellSize = currentCellSize / DISPLAY_SCALE
            const originalCellSize = currentCellSize / DISPLAY_SCALE;

            // compute canvas extents (treat images as already rotated in their src — do not apply additional rotation)
            // We'll load the images (to ensure we can draw them) but we will force the final canvas size to exactly match the grid's full size.
            let canvasWidth = 0, canvasHeight = 0;
            const imagesToLoad = refs.map(r => {
                return new Promise((resolve) => {
                    const im = new Image();
                    im.crossOrigin = 'anonymous';
                    im.onload = () => {
                        const origW = r.origW || im.naturalWidth || im.width;
                        const origH = r.origH || im.naturalHeight || im.height;
                        // Do not use r.rot here — rotation is encoded in the src filename already.
                        const x = r.col * originalCellSize;
                        const y = r.row * originalCellSize;
                        // keep previous behavior of computing extent, but we'll override with grid size below
                        canvasWidth = Math.max(canvasWidth, Math.ceil(x + origW));
                        canvasHeight = Math.max(canvasHeight, Math.ceil(y + origH));
                        resolve({ ref: r, img: im, origW, origH, x, y });
                    };
                    im.onerror = () => {
                        console.warn('Failed to load', r.src);
                        resolve({ ref: r, img: null });
                    };
                    im.src = r.src;
                });
            });

            const loaded = await Promise.all(imagesToLoad);

            // Force canvas dimensions to match the grid full original size
            const gridFullWidth = Math.max(1, Math.ceil(gridCols * originalCellSize));
            const gridFullHeight = Math.max(1, Math.ceil(gridRows * originalCellSize));
            canvasWidth = gridFullWidth;
            canvasHeight = gridFullHeight;

            // create canvas
            const canvas = document.createElement('canvas');
            canvas.width = canvasWidth;
            canvas.height = canvasHeight;
            const ctx = canvas.getContext('2d');

            // background (black as before)
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // draw images: first draw non-ontop images, then ontop images so ontop always appear above
            const normalEntries = loaded.filter(e => e.img && !(e.ref && e.ref.ontop));
            const ontopEntries = loaded.filter(e => e.img && e.ref && e.ref.ontop);

            for (const entry of normalEntries) {
                const { img, origW, origH, x, y } = entry;
                ctx.drawImage(img, x, y, origW, origH);
            }

            for (const entry of ontopEntries) {
                const { img, origW, origH, x, y } = entry;
                ctx.drawImage(img, x, y, origW, origH);
            }

            // create PNG blob
            canvas.toBlob(async (blob) => {
                if (!blob) {
                    alert('Failed to create image.');
                    return;
                }

                // build metadata
                var a1 = buildMetadata(originalCellSize)

                const metadata = [].concat(a1, imageGridRefs);
                // add mapName and grid refs for portals and chests as JSON in a tEXt chunk under keyword 'mapJSON'
                const metadataJson = JSON.stringify(metadata);

                try {
                    const j = JSON.stringify(imageGridRefs);

                    const withMeta = await addPngTextChunk(blob, 'mapJSON', metadataJson);
                    const url = URL.createObjectURL(withMeta);
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const mapSafe = safeFileName(mapNameInput && mapNameInput.value ? mapNameInput.value : '');
                    if (mapSafe) {
                        a.download = `${mapSafe}-${timestamp}.png`;
                    } else {
                        a.download = `combined-${timestamp}.png`;
                    }
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 150);
                } catch (err) {
                    console.error('Failed to attach metadata to PNG', err);
                    // fallback to downloading original blob
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
                    const mapSafe = safeFileName(mapNameInput && mapNameInput.value ? mapNameInput.value : '');
                    if (mapSafe) {
                        a.download = `${mapSafe}-${timestamp}.png`;
                    } else {
                        a.download = `combined-${timestamp}.png`;
                    }
                    document.body.appendChild(a);
                    a.click();
                    setTimeout(() => {
                        document.body.removeChild(a);
                        URL.revokeObjectURL(url);
                    }, 150);
                }
            }, 'image/png');
        });

        // Keep clones inside viewport if window resizes
        window.addEventListener('resize', () => {
            clones.forEach(img => {
                if (!img) return;
                const rect = img.getBoundingClientRect();
                const pos = clampPosition(rect.left, rect.top, img);
                img.style.left = pos.left + 'px';
                img.style.top = pos.top + 'px';
            });
        });

        // ensure new palette images are scaled when added later
        new MutationObserver(() => scalePaletteImages()).observe(document.getElementById('image-container'), { childList: true });
    </script>



</body>
</html>